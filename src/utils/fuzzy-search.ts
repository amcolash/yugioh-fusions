// generated by gemini
import levenshtein from 'js-levenshtein';

/**
 * (This is the same helper function you provided)
 * Finds the minimum Levenshtein distance between a search term and any substring
 * of the target string.
 */
function getMinSubstringDistance(searchTerm: string, target: string): number {
  const searchTermLen = searchTerm.length;
  const targetLen = target.length;

  // If the target is shorter than the search term, the best we can do is
  // a regular Levenshtein comparison.
  if (targetLen < searchTermLen) {
    return levenshtein(searchTerm, target);
  }

  let minDistance = Infinity;

  // Slide a window of the search term's length across the target string
  for (let i = 0; i <= targetLen - searchTermLen; i++) {
    const substring = target.substring(i, i + searchTermLen);
    const distance = levenshtein(searchTerm, substring);

    // If we find a perfect match, we can exit early
    if (distance === 0) {
      return 0;
    }

    if (distance < minDistance) {
      minDistance = distance;
    }
  }

  return minDistance;
}

/**
 * A type to hold match details for sorting.
 */
interface MatchDetail {
  item: string;
  minDistance: number;
  startsWithDistance: number;
}

/**
 * Filters and sorts a list of strings to find items that have a substring
 * that fuzzy-matches the search term, returning them in the most likely
 * intended order.
 *
 * @param searchTerm The string to search for.
 * @param list The array of strings to search within.
 * @param maxDistanceRatio The maximum allowed distance ratio. A lower number is stricter.
 * @returns A new array containing the sorted, matching items.
 */
export function fuzzySubstringSearch(searchTerm: string, list: string[], maxDistanceRatio: number = 0.4): string[] {
  if (!searchTerm) {
    return []; // Return empty if there's no search term
  }

  const normalizedSearchTerm = searchTerm.toLowerCase();
  const searchTermLen = normalizedSearchTerm.length;
  const maxDistance = Math.floor(searchTermLen * maxDistanceRatio);

  const matches: MatchDetail[] = [];

  for (const item of list) {
    const normalizedItem = item.toLowerCase();

    // Find the best possible substring match anywhere in the string
    const minDistance = getMinSubstringDistance(normalizedSearchTerm, normalizedItem);

    // Only consider items that are within the distance threshold
    if (minDistance <= maxDistance) {
      // Also calculate the distance for a "starts with" match to prioritize it
      const startsWithDistance = levenshtein(normalizedSearchTerm, normalizedItem.substring(0, searchTermLen));

      matches.push({
        item: item, // Store the original item
        minDistance: minDistance,
        startsWithDistance: startsWithDistance,
      });
    }
  }

  // Sort the results based on our ranking criteria
  matches.sort((a, b) => {
    // 1. Prioritize the best overall match (lowest minDistance)
    if (a.minDistance !== b.minDistance) {
      return a.minDistance - b.minDistance;
    }

    // 2. Prioritize "starts with" matches
    if (a.startsWithDistance !== b.startsWithDistance) {
      return a.startsWithDistance - b.startsWithDistance;
    }

    // 3. Prioritize shorter results as a tie-breaker
    if (a.item.length !== b.item.length) {
      return a.item.length - b.item.length;
    }

    // 4. Finally, sort alphabetically for stability
    return a.item.localeCompare(b.item);
  });

  // Return only the string items from the sorted list
  return matches.map((match) => match.item);
}
